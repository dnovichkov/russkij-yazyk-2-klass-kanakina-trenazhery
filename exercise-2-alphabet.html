<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>–£—Ä–æ–≤–µ–Ω—å 2 ‚Äî —Å–æ–±—Ä–∞—Ç—å –∏–∑ –ø–æ–ª–Ω–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞</title>
<style>
  :root{
    --bg:#f7fafc; --card:#fff; --accent:#0f62fe; --muted:#6b7280;
    --danger:#ff4d4f;
    --slot-size:48px;
  }
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);margin:0;color:#0b1220}
  header{padding:12px 16px;background:white;box-shadow:0 1px 0 rgba(0,0,0,0.04);display:flex;align-items:center;gap:12px}
  header a.home{background:var(--accent);color:#fff;padding:8px 10px;border-radius:8px;text-decoration:none;display:inline-block}
  header h1{font-size:1.05rem;margin:0}
  main{max-width:980px;margin:18px auto;padding:12px}
  .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.04);margin-bottom:12px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{background:var(--accent);color:#fff;padding:8px 12px;border-radius:10px;border:0;cursor:pointer;font-size:14px}
  .btn.alt{background:#6b7280}
  .btn[disabled]{opacity:0.45;cursor:not-allowed}
  .input{min-height:var(--slot-size);border:1px solid #e6eef8;padding:8px;border-radius:8px;font-size:20px;display:flex;gap:6px;align-items:center;flex-wrap:wrap;background:#fff}
  .slots{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .slot{min-width:var(--slot-size);min-height:var(--slot-size);border-radius:8px;background:#fff;border:2px dashed #e6eef8;display:flex;align-items:center;justify-content:center;font-size:20px;user-select:none;position:relative;color:#0b1220}
  .slot.space{background:transparent;border:0;min-width:32px}
  .slot.wrong{box-shadow:0 0 0 3px rgba(255,77,79,0.12);border-color:var(--danger)}
  .slot.focused{outline:3px solid rgba(15,98,254,0.12);box-shadow:0 6px 16px rgba(15,98,254,0.04)}
  .keyboard{display:grid;grid-template-columns:repeat(auto-fit,minmax(48px,1fr));gap:8px;margin-top:12px}
  .key{min-height:48px;border-radius:8px;background:#fff;border:1px solid #e6eef8;display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;font-size:18px;color:#0b1220}
  .key.selected{box-shadow:0 4px 10px rgba(2,6,23,0.08);outline:2px solid rgba(15,98,254,0.08)}
  .status{margin-top:10px;color:var(--muted);font-size:14px}
  .hint{background:#f9fafb;color:#374151;border-radius:8px;padding:6px;font-size:13px}
  .small{font-size:13px;color:var(--muted)}
  #feedback{margin-top:10px;font-weight:600}
  #answerRow { display:none; } /* –∑–µ—Ä–∫–∞–ª–æ —Å–∫—Ä—ã—Ç–æ, —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–ª–æ—Å—å */
  @media (max-width:480px){
    :root{--slot-size:44px}
    .key{min-height:44px;font-size:16px}
  }
</style>
</head>
<body>
<header>
  <a class="home" href="index.html">üè† –î–æ–º–æ–π</a>
  <h1>–£—Ä–æ–≤–µ–Ω—å 2 ‚Äî —Å–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –∏–∑ –ø–æ–ª–Ω–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞</h1>
</header>

<main>
  <div class="card" id="mainCard">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
      <div class="controls">
        <button id="playBtn">‚ñ∂ –î–∏–∫—Ç–æ–≤–∫–∞</button>
        <button id="slowBtn" class="btn alt">üê¢ –ú–µ–¥–ª–µ–Ω–Ω–æ</button>
        <button id="hintBtn" class="btn alt">üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
        <button id="shuffleBtn" class="btn alt">üîÄ –ü–µ—Ä–µ–º–µ—à–∞—Ç—å</button>
      </div>
      <div style="display:flex;gap:8px">
        <button id="submitBtn">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
        <button id="nextBtn" class="btn alt">–°–ª–µ–¥—É—é—â–µ–µ</button>
      </div>
    </div>

    <div class="status" style="margin-top:10px">
      <strong>–ü—Ä–æ–≥—Ä–µ—Å—Å:</strong> <span id="progress">0 / 0</span>
      <span style="margin-left:12px" class="small">–ù–∞–±–µ—Ä–∏—Ç–µ —Å–ª–æ–≤–æ —Å –ø–æ–º–æ—â—å—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –∏–ª–∏ —ç–∫—Ä–∞–Ω–∞ (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è drag & drop –∏ tap-to-select –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö).</span>
    </div>

    <div style="margin-top:12px">
      <!-- answerRow —Å–∫—Ä—ã—Ç, —Ä–µ–∑–µ—Ä–≤–∏—Ä—É–µ–º –µ–≥–æ –¥–ª—è accessibility -->
      <div class="input" aria-live="polite" id="answerRow" role="region" aria-label="–û—Ç–≤–µ—Ç ‚Äî —Å–æ–±–µ—Ä–∏—Ç–µ —Å–ª–æ–≤–æ"></div>

      <div id="slotsWrap" class="slots" aria-hidden="false"></div>

      <div id="feedback" role="status" aria-live="polite"></div>
    </div>

    <div class="card" style="margin-top:12px">
      <div><strong>–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞:</strong></div>
      <div id="keyboard" class="keyboard" aria-label="–≠–∫—Ä–∞–Ω–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞"></div>
      <div style="margin-top:8px" class="small">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –±—É–∫–≤—É, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –µ—ë –≤ –≤—ã–±—Ä–∞–Ω–Ω—É—é —è—á–µ–π–∫—É –∏–ª–∏ –≤ –ø–µ—Ä–≤–æ–µ –ø—É—Å—Ç–æ–µ –º–µ—Å—Ç–æ. –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö ‚Äî —Ç–∞–ø–Ω–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ –∏ –∑–∞—Ç–µ–º —Ç–∞–ø–Ω–∏—Ç–µ –Ω–∞ —Å–ª–æ—Ç.</div>
    </div>
  </div>

  <div class="card">
    <h3>–ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∏</h3>
    <ul>
      <li>–§–∏–∑–∏—á–µ—Å–∫–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞: –≤–≤–æ–¥ —Ä—É—Å—Å–∫–∏–º–∏ –±—É–∫–≤–∞–º–∏ –∑–∞–ø–æ–ª–Ω—è–µ—Ç —Å–ª–æ—Ç—ã; Backspace ‚Äî —É–¥–∞–ª—è–µ—Ç –±—É–∫–≤—É –≤ —Ñ–æ–∫—É—Å–µ –∏–ª–∏ –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—É—é; Enter ‚Äî –ø—Ä–æ–≤–µ—Ä–∫–∞.</li>
      <li>–ü–æ–¥—Å–∫–∞–∑–∫–∞ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –ø–µ—Ä–≤—É—é –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—É—é –±—É–∫–≤—É. –ö–Ω–æ–ø–∫–∞ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è, –∫–æ–≥–¥–∞ —Å–ª–æ–≤–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç–∫—Ä—ã—Ç–æ.</li>
      <li>–ü—Ä–æ–≥—Ä–µ—Å—Å —É—á–∏—Ç—ã–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å–æ–±—Ä–∞–Ω–Ω—ã–µ —Å–ª–æ–≤–∞.</li>
    </ul>
  </div>
</main>

<script>
/* –ü–æ–ª–Ω—ã–π –∑–∞—â–∏—â—ë–Ω–Ω—ã–π —Ñ–∞–π–ª —Å –∫—É—Ä—Å–æ—Ä–æ–º (focusIndex) –¥–ª—è –≤–≤–æ–¥–∞ —Ñ—Ä–∞–∑ —Å –ø—Ä–æ–±–µ–ª–∞–º–∏ */

/* ---------- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---------- */
const AUTO_NEXT_DELAY = 600;
let autoNextTimeoutId = null;

/* –ê–ª—Ñ–∞–≤–∏—Ç */
const ALPHABET = ['–∞','–±','–≤','–≥','–¥','–µ','—ë','–∂','–∑','–∏','–π','–∫','–ª','–º','–Ω','–æ','–ø','—Ä','—Å','—Ç','—É','—Ñ','—Ö','—Ü','—á','—à','—â','—ä','—ã','—å','—ç','—é','—è'];

/* –°–ø–∏—Å–æ–∫ —Å–ª–æ–≤/—Ñ—Ä–∞–∑ */
const WORDS = [
"–∞–ª—Ñ–∞–≤–∏—Ç","–∞–ø—Ä–µ–ª—å","–±–µ—Ä—ë–∑–∞","–±—ã—Å—Ç—Ä–æ","–≤–¥—Ä—É–≥","–≤–µ—Å–µ–ª–æ","–≤–µ—Ç–µ—Ä","–≤–æ—Ä–æ–±–µ–π","–≤–æ—Ä–æ–Ω–∞",
"–≥–æ—Ä–æ–¥","–¥–µ–≤–æ—á–∫–∞","–¥–µ–∂—É—Ä–Ω—ã–π","–¥–µ–∫–∞–±—Ä—å","–¥–µ—Ä–µ–≤–Ω—è","–¥–æ—Ä–æ–≥–∞","–¥–æ —Å–≤–∏–¥–∞–Ω–∏—è",
"–∑–∞–≤–æ–¥","–∑–∞—è—Ü","–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ","–∑–µ–º–ª—è–Ω–∏–∫–∞","–∏–∑–≤–∏–Ω–∏—Ç–µ","–∏–Ω–µ–π","–∫–∞–ø—É—Å—Ç–∞","–∫–∞—Ä–∞–Ω–¥–∞—à",
"–∫–∞—Ä—Ç–∏–Ω–∞","–∫–ª–∞—Å—Å","–∫–æ–Ω—å–∫–∏","–∫–æ—Ä–æ–≤–∞","–ª–æ–ø–∞—Ç–∞","–ª—è–≥—É—à–∫–∞","–º–∞–≥–∞–∑–∏–Ω","–º–∞–ª–∏–Ω–∞","–º–∞—à–∏–Ω–∞",
"–º–µ–±–µ–ª—å","–º–µ–¥–≤–µ–¥—å","–º–µ—Å—è—Ü","–º–µ—Ç–µ–ª—å","–º–µ—Ç—Ä–æ","–º–æ–ª–æ–∫–æ","–º–æ–ª–æ—Ç–æ–∫","–º–æ—Ä–∫–æ–≤—å","–º–æ—Ä–æ–∑","–º–æ—Å–∫–≤–∞",
"–Ω–∞—Ä–æ–¥","–Ω–æ—è–±—Ä—å","–æ–±–µ–¥","–æ–±–µ–∑—å—è–Ω–∞","–æ–±–ª–∞–∫–æ","–æ–¥–µ–∂–¥–∞","–æ–∫—Ç—è–±—Ä—å","–æ—Å–∏–Ω–∞","–æ—Ç–µ—Ü",
"–ø–∞–ª—å—Ç–æ","–ø–µ–Ω–∞–ª","–ø–µ—Ç—É—Ö","–ø–ª–∞—Ç—å–µ","–ø–æ—Å—É–¥–∞","–ø—Ä–æ—â–∞–π","—Ä–∞–±–æ—Ç–∞","—Ä–∞–±–æ—á–∏–π","—Ä–µ–±—è—Ç–∞","—Ä–∏—Å—É–Ω–æ–∫",
"—Ä–æ–¥–∏–Ω–∞","—Ä–æ—Å—Å–∏—è","—Ä—É—Å—Å–∫–∏–π","—Å–∞–ø–æ–≥–∏","—Å–∞—Ö–∞—Ä","—Å–µ–Ω—Ç—è–±—Ä—å","—Å–∫–æ—Ä–æ","—Å–Ω–µ–≥–∏—Ä—å","—Å–æ–±–∞–∫–∞","—Å–æ—Ä–æ–∫–∞",
"—Å–ø–∞—Å–∏–±–æ","—Å—Ç–∞–∫–∞–Ω","—Å—É–±–±–æ—Ç–∞","—Ç–∞—Ä–µ–ª–∫–∞","—Ç–µ—Ç—Ä–∞–¥—å","—Ç–æ–≤–∞—Ä–∏—â","—Ç–æ–ø–æ—Ä","—É–ª–∏—Ü–∞","—É—Ä–æ–∂–∞–π",
"—É—á–µ–Ω–∏–∫","—É—á–µ–Ω–∏—Ü–∞","—É—á–∏—Ç–µ–ª—å","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü–∞","—Ñ–∞–º–∏–ª–∏—è","—Ñ–µ–≤—Ä–∞–ª—å","—Ö–æ—Ä–æ—à–æ","—â–∞–≤–µ–ª—å",
"—è–±–ª–æ–∫–æ","—è–±–ª–æ–Ω—è","—è–≥–æ–¥–∞","—è–∑—ã–∫","—è–Ω–≤–∞—Ä—å"
];

/* ---------- DOM —ç–ª–µ–º–µ–Ω—Ç—ã ---------- */
const progressEl = document.getElementById('progress');
const keyboardEl = document.getElementById('keyboard');
const answerRow = document.getElementById('answerRow'); // —Å–∫—Ä—ã—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ
const slotsWrap = document.getElementById('slotsWrap');
const feedback = document.getElementById('feedback');
const hintBtn = document.getElementById('hintBtn');

/* ---------- –°–æ—Å—Ç–æ—è–Ω–∏–µ ---------- */
let pool = [];
let idx = 0;
let completed = 0;
let current = '';
let slotsState = []; // '' | ' ' | letter
let focusIndex = null; // –∏–Ω–¥–µ–∫—Å —è—á–µ–π–∫–∏, –≤ –∫–æ—Ç–æ—Ä—É—é –±—É–¥–µ—Ç –≤—Å—Ç–∞–≤–ª—è—Ç—å—Å—è —Å–ª–µ–¥—É—é—â–∞—è –±—É–∫–≤–∞ (–∏–ª–∏ null)
const STORAGE_KEY = 'russian_alphabet_progress_v4';

/* Touch detection –∏ selection */
const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
let selectedKey = null;

/* ---------- –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –ª–æ–≥–æ–≤ –∏ feedback ---------- */
function safeLog(...args){ try{ console.log(...args);}catch(e){} }
function safeError(...args){ try{ console.error(...args);}catch(e){} }
function showFeedback(text, isError=false){ try{ feedback.style.color = isError ? 'crimson' : 'green'; feedback.textContent = text; }catch(e){} }

/* ---------- Global error handlers ---------- */
window.addEventListener('error', (ev) => {
  safeError('Global error:', ev);
  showFeedback('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ ‚Äî —Å–º–æ—Ç—Ä–∏—Ç–µ –∫–æ–Ω—Å–æ–ª—å.', true);
});
window.addEventListener('unhandledrejection', (ev) => {
  safeError('Unhandled rejection:', ev);
  showFeedback('–û—à–∏–±–∫–∞ (Promise). –°–º–æ—Ç—Ä–∏—Ç–µ –∫–æ–Ω—Å–æ–ª—å.', true);
});

/* ---------- TTS (–∑–∞—â–∏—Ç–∞) ---------- */
function loadVoices(){ try { return speechSynthesis.getVoices() || []; } catch(e){ return []; } }
function waitVoices(timeout = 1000){ return new Promise(resolve => {
  try {
    const vs = loadVoices();
    if (vs.some(v => v.lang && v.lang.toLowerCase().startsWith('ru'))) { resolve(true); return; }
  } catch(e){}
  let waited = 0; const step = 150;
  const iv = setInterval(()=>{
    try {
      const vs2 = loadVoices(); waited += step;
      if (vs2.some(v => v.lang && v.lang.toLowerCase().startsWith('ru')) || waited >= timeout) { clearInterval(iv); resolve(true); }
    } catch(e){ clearInterval(iv); resolve(false); }
  }, step);
}); }
function chooseRussianVoice(){ try { const vs = loadVoices(); let v = vs.find(x => x.lang && x.lang.toLowerCase().startsWith('ru')); if (!v) v = vs.find(x => /russian/i.test(x.name)); return v || null; } catch(e) { return null; } }
function speakText(text, rate=1.0){ try { if (!('speechSynthesis' in window)) return; const u = new SpeechSynthesisUtterance(text); const v = chooseRussianVoice(); if (v) u.voice = v; u.rate = rate; speechSynthesis.cancel(); speechSynthesis.speak(u); } catch(e) { safeError('speakText', e); } }

/* ---------- localStorage safe ---------- */
function saveProgress(){ try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ pool, idx, completed })); } catch(e){ safeError('saveProgress', e); } }
function loadProgress(){ try { const raw = localStorage.getItem(STORAGE_KEY); if (!raw) return false; const obj = JSON.parse(raw); if (obj && Array.isArray(obj.pool) && typeof obj.idx === 'number' && typeof obj.completed === 'number'){ pool = obj.pool; idx = obj.idx; completed = obj.completed; return true; } } catch(e){ safeError('loadProgress', e); } return false; }

/* ---------- Pool / progress ---------- */
function initPool(){ try { pool = [...WORDS]; pool.sort(()=>Math.random()-0.5); idx = 0; completed = 0; updateProgress(); } catch(e){ safeError('initPool', e); } }
function updateProgress(){ try { progressEl.textContent = `${completed} / ${pool.length}`; } catch(e){ safeError('updateProgress', e); } }

/* ---------- Safe element creation ---------- */
function safeCreateEl(tag, props = {}){ const el = document.createElement(tag); Object.entries(props).forEach(([k,v])=>{ if (k === 'text') el.textContent = v; else if (k === 'html') el.innerHTML = v; else el.setAttribute(k, String(v)); }); return el; }

/* ---------- Render keyboard (–±–µ–∑ per-button click handler) ---------- */
function renderKeyboard(){
  try {
    if (!keyboardEl) return;
    keyboardEl.innerHTML = '';
    const letters = Array.isArray(ALPHABET) && ALPHABET.length ? ALPHABET : ['–∞','–±','–≤','–≥','–¥','–µ','—ë','–∂','–∑','–∏','–π','–∫','–ª','–º','–Ω','–æ','–ø','—Ä','—Å','—Ç','—É','—Ñ','—Ö','—Ü','—á','—à','—â','—ä','—ã','—å','—ç','—é','—è'];
    letters.forEach(letter => {
      const b = safeCreateEl('button', { 'class': 'key', 'type': 'button', 'text': letter });
      b.dataset.letter = letter;
      b.style.color = '#0b1220';
      // –ù–ï –≤–µ—à–∞–µ–º per-button click (–∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ), —Ç–æ–ª—å–∫–æ dragstart
      b.addEventListener('dragstart', onKeyDragStart);
      keyboardEl.appendChild(b);
    });
  } catch(e) { safeError('renderKeyboard', e); }
}

/* ---------- Render slots ---------- */
function renderSlots(word){
  try {
    if (!slotsWrap || !answerRow) return;
    const letters = Array.from(String(word));
    slotsState = letters.map(ch => ch === ' ' ? ' ' : '');
    slotsWrap.innerHTML = '';
    answerRow.innerHTML = '';
    letters.forEach((ch, i) => {
      const slot = safeCreateEl('div', { 'class': 'slot' + (ch === ' ' ? ' space' : '' ) });
      slot.dataset.pos = i;
      slot.dataset.accepts = ch === ' ' ? 'no' : 'yes';
      slot.setAttribute('role','textbox');
      slot.setAttribute('tabindex','0');
      slot.setAttribute('aria-label', ch === ' ' ? '–ø—Ä–æ–±–µ–ª' : `—Å–ª–æ—Ç ${i+1}`);
      slot.addEventListener('click', onSlotClick);
      slot.addEventListener('dragover', onSlotDragOver);
      slot.addEventListener('drop', onSlotDrop);
      slot.addEventListener('dragenter', onSlotDragEnter);
      slot.addEventListener('dragleave', onSlotDragLeave);
      const content = safeCreateEl('div', { 'class': 'slot-content', 'text': ch === ' ' ? ' ' : '' });
      content.style.pointerEvents = 'none';
      content.style.width = '100%';
      content.style.textAlign = 'center';
      slot.appendChild(content);
      slotsWrap.appendChild(slot);

      // mirror (hidden)
      const mirror = slot.cloneNode(true);
      mirror.className = 'slot';
      mirror.style.border = 'none';
      answerRow.appendChild(mirror);
    });
    updateSlotsUI();
    updateHintButtonState();
    clearFocus(); // —Å–±—Ä–æ—Å —Ñ–æ–∫—É—Å–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –Ω–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞
  } catch(e) { safeError('renderSlots', e); }
}

/* ---------- Drag handlers for keys/slots ---------- */
function onKeyDragStart(e){
  try {
    const key = e.currentTarget;
    e.dataTransfer.setData('text/plain', JSON.stringify({ from: 'key', letter: key.dataset.letter }));
    if (e.dataTransfer.setDragImage) {
      const crt = key.cloneNode(true);
      crt.style.position='absolute'; crt.style.top='-1000px'; crt.style.left='-1000px';
      document.body.appendChild(crt);
      e.dataTransfer.setDragImage(crt, 18, 18);
      setTimeout(()=> document.body.removeChild(crt), 0);
    }
  } catch(e){ safeError('onKeyDragStart', e); }
}

function onSlotDragStart(e){
  try {
    const slot = e.currentTarget;
    const pos = Number(slot.dataset.pos);
    const ch = slotsState[pos];
    if (!ch || ch === ' ') { e.preventDefault(); return; }
    e.dataTransfer.setData('text/plain', JSON.stringify({ from: 'slot', pos, letter: ch }));
  } catch(e){ safeError('onSlotDragStart', e); }
}
function onSlotDragOver(e){ try { e.preventDefault(); } catch(e){} }
function onSlotDragEnter(e){ try { e.currentTarget.classList.add('dragover'); } catch(e){} }
function onSlotDragLeave(e){ try { e.currentTarget.classList.remove('dragover'); } catch(e){} }
function onSlotDrop(e){
  try {
    e.preventDefault(); e.currentTarget.classList.remove('dragover');
    let payload;
    try { payload = JSON.parse(e.dataTransfer.getData('text/plain')); } catch(err){ return; }
    const pos = Number(e.currentTarget.dataset.pos);
    if (e.currentTarget.dataset.accepts === 'no') return;
    if (payload.from === 'key') {
      placeLetter(payload.letter, pos);
    } else if (payload.from === 'slot') {
      const fromPos = payload.pos;
      if (fromPos === pos) return;
      const tmp = slotsState[pos];
      slotsState[pos] = slotsState[fromPos];
      slotsState[fromPos] = tmp;
      updateSlotsUI();
      updateHintButtonState();
      setFocus(pos);
    }
  } catch(e){ safeError('onSlotDrop', e); }
}

/* ---------- Focus / cursor logic ---------- */
function setFocus(pos){
  try {
    Array.from(slotsWrap.children).forEach(el => el.classList.remove('focused'));
    if (typeof pos === 'number' && pos >= 0 && pos < slotsState.length && slotsWrap.children[pos]) {
      focusIndex = pos;
      slotsWrap.children[pos].classList.add('focused');
    } else {
      focusIndex = null;
    }
  } catch(e) { safeError('setFocus', e); }
}
function clearFocus(){ setFocus(null); }

/* find first editable after position */
function findFirstEditableAfter(pos){
  for (let i = pos + 1; i < slotsState.length; i++){
    if (slotsState[i] === '') return i;
  }
  return -1;
}

/* ---------- placeLetter: –≥–ª–∞–≤–Ω—ã–π API –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ —Å —É—á—ë—Ç–æ–º –∫—É—Ä—Å–æ—Ä–∞ ---------- */
function placeLetter(letter, pos = null){
  try {
    let target = null;
    if (typeof pos === 'number') target = pos;
    else if (typeof focusIndex === 'number') target = focusIndex;
    else target = slotsState.findIndex(s => s === '');

    if (target === -1 || target === null) return false;

    // –µ—Å–ª–∏ —Å–ª–æ—Ç ‚Äî –ø—Ä–æ–±–µ–ª, –Ω–∞–π–¥—ë–º —Å–ª–µ–¥—É—é—â–∏–π
    if (slotsWrap.children[target] && slotsWrap.children[target].dataset.accepts === 'no') {
      const nxt = findFirstEditableAfter(target);
      if (nxt !== -1) target = nxt;
      else return false;
    }

    slotsState[target] = letter;
    updateSlotsUI();
    updateHintButtonState();

    if (letter === ' ') {
      const nxt = findFirstEditableAfter(target);
      if (nxt !== -1) setFocus(nxt);
      else clearFocus();
    } else {
      const nextEmpty = slotsState.findIndex((s, i) => i > target && s === '');
      if (nextEmpty !== -1) setFocus(nextEmpty);
      else clearFocus();
    }
    return true;
  } catch(e) { safeError('placeLetter', e); return false; }
}

/* convenience wrapper to keep previous name */
function placeLetterToFirstEmpty(letter){ return placeLetter(letter, null); }

/* ---------- Slot click handler (–æ–±–Ω–æ–≤–ª—ë–Ω) ---------- */
function onSlotClick(e){
  try {
    const slotEl = e.currentTarget;
    const pos = Number(slotEl.dataset.pos);
    if (slotEl.dataset.accepts === 'no') return;
    if (isTouch && selectedKey) {
      placeLetter(selectedKey.dataset.letter, pos);
      if (selectedKey) { selectedKey.classList.remove('selected'); selectedKey = null; }
      return;
    }
    setFocus(pos);
  } catch(e){ safeError('onSlotClick', e); }
}

/* ---------- Keyboard delegation (–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π click handler) ---------- */
if (keyboardEl) {
  keyboardEl.addEventListener('click', (e) => {
    try {
      const key = e.target.closest('.key');
      if (!key || !keyboardEl.contains(key)) return;
      const letter = key.dataset.letter;
      if (isTouch) {
        const prev = keyboardEl.querySelector('.key.selected');
        if (prev && prev !== key) prev.classList.remove('selected');
        key.classList.toggle('selected');
        selectedKey = key.classList.contains('selected') ? key : null;
      } else {
        placeLetter(letter, null);
      }
    } catch(err){ safeError('keyboard delegation', err); }
  });
}

/* ---------- Physical keyboard handler (–æ–±–Ω–æ–≤–ª—ë–Ω) ---------- */
document.addEventListener('keydown', (e) => {
  try {
    if (e.key === 'Backspace') {
      e.preventDefault();
      if (typeof focusIndex === 'number') {
        if (slotsState[focusIndex] && slotsState[focusIndex] !== ' ') {
          slotsState[focusIndex] = '';
          updateSlotsUI(); updateHintButtonState(); setFocus(focusIndex);
          return;
        } else {
          for (let i = focusIndex - 1; i >= 0; i--){
            if (slotsState[i] && slotsState[i] !== ' ') { slotsState[i] = ''; updateSlotsUI(); updateHintButtonState(); setFocus(i); return; }
          }
        }
      }
      for (let i = slotsState.length - 1; i >= 0; i--){
        if (slotsState[i] && slotsState[i] !== ' ') {
          slotsState[i] = '';
          updateSlotsUI(); updateHintButtonState(); setFocus(i);
          break;
        }
      }
      return;
    }
    if (e.key === 'Enter') { e.preventDefault(); checkAnswer(); return; }
    if (e.key === ' ') {
      e.preventDefault();
      let targetPos = (typeof focusIndex === 'number') ? focusIndex : slotsState.findIndex(s => s === '');
      if (targetPos !== -1) placeLetter(' ', targetPos);
      return;
    }
    const k = e.key.toLowerCase();
    if (k.length === 1 && (ALPHABET.includes(k) || k === '—ë')) {
      placeLetter(k, null);
    }
  } catch(err){ safeError('physical keyboard', err); }
});

/* ---------- UI update ---------- */
function updateSlotsUI(){
  try {
    Array.from(slotsWrap.children).forEach((el, i) => {
      const ch = slotsState[i];
      const content = el.querySelector('.slot-content');
      if (content) content.textContent = ch === ' ' ? ' ' : (ch || '');
      if (el.draggable && (!slotsState[i] || slotsState[i] === ' ')) {
        el.draggable = false; el.removeEventListener('dragstart', onSlotDragStart);
      }
      if (!el.draggable && slotsState[i] && slotsState[i] !== ' ') {
        el.draggable = true; el.addEventListener('dragstart', onSlotDragStart);
      }
      el.classList.remove('wrong');
    });
    // maintain focused class if focusIndex set
    if (typeof focusIndex === 'number' && slotsWrap.children[focusIndex]) {
      Array.from(slotsWrap.children).forEach(el => el.classList.remove('focused'));
      slotsWrap.children[focusIndex].classList.add('focused');
    }
  } catch(e){ safeError('updateSlotsUI', e); }
}

/* ---------- Hint behavior ---------- */
function revealNextLetter(){
  try {
    const targetPos = slotsState.findIndex(s => s === '');
    if (targetPos === -1) { updateHintButtonState(); return; }
    const letters = Array.from(current);
    const targetLetter = letters[targetPos];
    if (!targetLetter) { updateHintButtonState(); return; }
    const otherPos = slotsState.findIndex((s, idx) => s && s.toLowerCase() === targetLetter.toLowerCase() && idx !== targetPos);
    if (otherPos !== -1) {
      slotsState[otherPos] = '';
      slotsState[targetPos] = targetLetter;
      updateSlotsUI(); updateHintButtonState(); setFocus(targetPos); return;
    }
    slotsState[targetPos] = targetLetter;
    updateSlotsUI(); updateHintButtonState(); setFocus(targetPos);
  } catch(e){ safeError('revealNextLetter', e); }
}
function updateHintButtonState(){ try { const anyEmpty = Array.isArray(slotsState) && slotsState.some(s => s === ''); if (hintBtn) hintBtn.disabled = !anyEmpty; } catch(e){ safeError('updateHintButtonState', e); } }

/* ---------- Check / auto-next ---------- */
function getAssembled(){ try { return slotsState.map(s => s === ' ' ? ' ' : (s || '')).join(''); } catch(e) { safeError('getAssembled', e); return ''; } }
function highlightWrongSlots(assembled, target){
  try {
    const aArr = Array.from(assembled);
    const tArr = Array.from(target);
    const maxLen = Math.max(aArr.length, tArr.length);
    for (let i=0;i<maxLen;i++){
      const a = aArr[i] || '';
      const t = tArr[i] || '';
      const slotEl = slotsWrap.querySelector(`.slot[data-pos="${i}"]`);
      if (!slotEl) continue;
      if (t === ' ') continue;
      if (!a || a.toLowerCase() !== t.toLowerCase()) slotEl.classList.add('wrong'); else slotEl.classList.remove('wrong');
    }
  } catch(e){ safeError('highlightWrongSlots', e); }
}
function checkAnswer(){
  try {
    if (autoNextTimeoutId) { clearTimeout(autoNextTimeoutId); autoNextTimeoutId = null; }
    const assembled = getAssembled();
    const target = current;
    if (assembled.toLowerCase() === target.toLowerCase()) {
      if ('speechSynthesis' in window) try { speechSynthesis.cancel(); } catch(e){}
      showFeedback('–ü—Ä–∞–≤–∏–ª—å–Ω–æ! üéâ', false);
      completed++; idx++; saveProgress(); updateProgress();
      autoNextTimeoutId = setTimeout(()=> { autoNextTimeoutId = null; pickNext(); }, AUTO_NEXT_DELAY);
    } else {
      if (autoNextTimeoutId) { clearTimeout(autoNextTimeoutId); autoNextTimeoutId = null; }
      showFeedback('–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ ‚Äî –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë.', true);
      highlightWrongSlots(assembled, target);
    }
  } catch(e){ safeError('checkAnswer', e); showFeedback('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ ‚Äî —Å–º–æ—Ç—Ä–∏—Ç–µ –∫–æ–Ω—Å–æ–ª—å.', true); }
}

/* ---------- Pick next word ---------- */
function pickNext(){
  try {
    if (autoNextTimeoutId) { clearTimeout(autoNextTimeoutId); autoNextTimeoutId = null; }
    if (!pool || pool.length === 0) initPool();
    if (idx >= pool.length) { alert('–í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ —Å–ª–æ–≤–∞! –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–Ω–æ–≤–æ.'); initPool(); }
    current = pool[idx] || '';
    renderSlots(current);
    showFeedback('', false);
    waitVoices(1000).then(()=> setTimeout(()=> speakText(current, 1.0), 150)).catch(()=>{});
    updateProgress();
  } catch(e){ safeError('pickNext', e); showFeedback('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ª–æ–≤–∞ ‚Äî —Å–º–æ—Ç—Ä–∏—Ç–µ –∫–æ–Ω—Å–æ–ª—å.', true); }
}

/* ---------- Buttons wiring ---------- */
try {
  const playBtn = document.getElementById('playBtn'); if (playBtn) playBtn.addEventListener('click', ()=> speakText(current, 1.0));
  const slowBtn = document.getElementById('slowBtn'); if (slowBtn) slowBtn.addEventListener('click', ()=> speakText(current, 0.8));
  if (hintBtn) hintBtn.addEventListener('click', revealNextLetter);
  const shuffleBtn = document.getElementById('shuffleBtn'); if (shuffleBtn) shuffleBtn.addEventListener('click', ()=> { pool.sort(()=>Math.random()-0.5); saveProgress(); showFeedback('–°–ª–æ–≤–∞ –ø–µ—Ä–µ–º–µ—à–∞–Ω—ã.', false); });
  const submitBtn = document.getElementById('submitBtn'); if (submitBtn) submitBtn.addEventListener('click', checkAnswer);
  const nextBtn = document.getElementById('nextBtn'); if (nextBtn) nextBtn.addEventListener('click', ()=> { if (autoNextTimeoutId) { clearTimeout(autoNextTimeoutId); autoNextTimeoutId = null; } idx++; pickNext(); });
} catch(e){ safeError('button wiring', e); }

/* ---------- Init ---------- */
function safeInit(){
  try {
    if (!loadProgress()) initPool();
    renderKeyboard();
    pickNext();
    updateProgress();
    showFeedback('', false);
  } catch(e) { safeError('safeInit', e); showFeedback('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ ‚Äî —Å–º–æ—Ç—Ä–∏—Ç–µ –∫–æ–Ω—Å–æ–ª—å.', true); }
}
safeInit();

/* cleanup */
window.addEventListener('beforeunload', ()=> { try { if (autoNextTimeoutId) clearTimeout(autoNextTimeoutId); } catch(e){} });

</script>
</body>
</html>
